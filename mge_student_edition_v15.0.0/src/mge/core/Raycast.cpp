#include "Raycast.hpp"

/// -------------------------------------------------------------------------------------------------------------------
/// This function returns TRUE if a ray intersects a triangle.
/// 	It also calculates the UV coordinates of said colision as part of the intersection test,
/// 	but does not return them.
///
/// V0xyz, V1xyz, and V2xyz are the locations of the three vertices of the triangle.
///
///	These vertices should be wound in CLOCKWISE order.  By clockwise I mean that if you face the front side of the
/// 	trianngle, the vertcies go around the trangle from V0 to V1 to V2 in a clockwise direction.  This is the same
/// 	as Blitz, so just pass the vertcies for a triangle in the same order that Blitz does.
///
///	The UV's generated by the function are set up as follows:
///		V0 is the location of UV(0,0)
/// 		V1 is the location of UV(0,1)
/// 		V2 is the location of UV(1,0)
///
/// 	This is useful to know if you want to know the exact location in texture space of the collision.
///	You can easily modify the function to return the values of T#, U#, and V#.
///
///Pxyz is a the start of the line.
///	Triangles which are "behind" this point are ignored.
///	"Behind" is defined as the direction opposite that which Dxyz points in.
///
///Dxyz is a vector providing the slope of the line.
///	Dxyz does not have to be normalized.
///
///If Extend_To_Infinity is set to false, then the length of Dxyz is how far the ray extends.
///	So if you want an endpoint on your ray beyond which no triangles will be detected, subtract the position
///	of Pxyz from your endpoint's position, and pass that ato the function as Dxyz.  Ie: (Dx = P2x-P1x)
///
///If Cull_Backfaces is set to true, then if the specified ray passes through the triangle from it's back side, then
///it will not register that it hit that triangle.
/// -------------------------------------------------------------------------------------------------------------------
bool Raycast::Ray_Intersect_Triangle(glm::vec3 pStartPoint, glm::vec3 pSlopeLine, glm::vec3 pVertice0, glm::vec3 pVertice1, glm::vec3 pVertice2, bool pExtend_To_Infinity=true, bool pCull_Backfaces=false)
{
    //Calculate the vector that represents the first side of the triangle.
    glm::vec3 triangleSide1 = pVertice2 - pVertice0;

    //Calculate the vector that represents the second side of the triangle.
    glm::vec3 triangleSide2 = pVertice1 - pVertice0;

    //Calculate a vector which is perpendicular to the vector between point 0 and point 1,
    //and the direction vector for the ray.
    //trianleNormal = Crossproduct(SlopeLine, E2)
    float triangleNormalx = (pSlopeLine.y * triangleSide2.z) - (triangleSide2.y * pSlopeLine.z);
    float triangleNormaly = (pSlopeLine.z * triangleSide2.x) - (triangleSide2.z * pSlopeLine.x);
    float triangleNormalz = (pSlopeLine.x * triangleSide2.y) - (triangleSide2.x * pSlopeLine.y);
    glm::vec3 triangleNormal = glm::vec3(triangleNormalx, triangleNormaly, triangleNormalz);

    //Calculate the dot product of the above vector and the vector between point 0 and point 2.
    float dotProduct = (triangleSide1.x * triangleNormal.x) + (triangleSide1.y * triangleNormal.y) + (triangleSide1.z * triangleNormal.z);

    //If we should ignore triangles the ray passes through the back side of,
    //and the ray points in the same direction as the normal of the plane,
    //then the ray passed through the back side of the plane,
    //and the ray does not intersect the plane the triangle is in.
    if(pCull_Backfaces == true && dotProduct >= 0) return false;

    //If the ray is almost parallel to the pane,
    //then the ray does not intersect the plane the triangle lies in.
    if(dotProduct > -0.00001 && dotProduct < 0.00001) return false;

    //inverse Dot Product.
    //(Scaling factor for UV's?)
    float inverseDotProduct = 1.0 / dotProduct;

    //Calculate a vector between the starting point of our ray, and the first point of the triangle,
    //which is at UV(0,0)
    float DVx = pStartPoint.x - pVertice0.x;
    float DVy = pStartPoint.y - pVertice0.y;
    float DVz = pStartPoint.z - pVertice0.z;
    glm::vec3 distanceVector = glm::vec3(DVx, DVy, DVz);

    //Calculate the U coordinate of the Intersection point.
    // distanceVector is the vector between the start of our ray and the first point of the triangle.
    // triangleNormal is the Normal of the triangle.
    //dotProductResult = inverseDotProduct * (dotproduct of (distanceVector, triangleNormal))
    float U = inverseDotProduct * ((distanceVector.x * triangleNormal.x) + (distanceVector.y * triangleNormal.y) + (distanceVector.z * triangleNormal.z));

    //Is the U coordinate outside the range of values inside the Triangle?
    if(U < 0.0 || U > 1.0) return false; //The ray has intersected the plane outside the triangle;

    //Not sure what this is, but it's definitely NOT the intersection point.
    //  distanceVector is the vector from the starting point of the ray to the first corner of the triangle.
    //  triangleSide1 is the vector which represents the first side of the Triangle.
    //  the crossproduct of these two would be a vector which is perpendicular to both.
    //perpendicularVector = CrossProduct(distanceVector, triangleSide1.
    float perpVectorx = (distanceVector.y * triangleSide1.z) - (triangleSide1.y * distanceVector.z);
    float perpVectory = (distanceVector.z * triangleSide1.x) - (triangleSide1.z * distanceVector.x);
    float perpVectorz = (distanceVector.x * triangleSide1.y) - (triangleSide1.x * distanceVector.y);
    glm::vec3 perpendicularVector = glm::vec3(perpVectorx, perpVectory, perpVectorz);

    //Calculate the V coordinate of the intersection point
    //  pSlopeLine is the vector which represents the direction the ray is pointing in.
    //  perpendicularVector is the intersection point i think?
    // V = inverseDotProduct * dotproduct(pSlopeLine & perpendicularVector)
    float V = inverseDotProduct * ((pSlopeLine.x * perpendicularVector.x) + (pSlopeLine.y * perpendicularVector.y) + (pSlopeLine.z * perpendicularVector.z));

    //is the V coordinate outside the range of values inside the triangle?
    // does perpendicularVector + V exceed 1.0?
    if  (V < 0.0f || (U + V) > 1.0f)
    {
        //the ray has intersected the plane outsde the trianlge.
        return false;

        //the reason we check the perpendicularVector+V is because you imagine the triangle as half a square, PV = 1 and V = 1 would
        //be in the lower left hand corner which would be in the lower left triangle making up the square.
        //than or equal to 1.0 if the point is in the upper right of the triangle.
    }

    //Calculate the distance of the the intersection point from the starting point of the ray, pStartLine.
    //This distance is scaled so that at pStartLine, the start of the ray, T = 0, and at pLineSlope, the end of the ray, T=1.
    //if the intersection point is behind pStartLine, then T will be negative, and if the intersection point is
    //beyond pLineSlope then T will be greater than 1.
    float T = inverseDotProduct * ((triangleSide2.x *  perpendicularVector.x) +  (triangleSide2.y * perpendicularVector.y) + (triangleSide2.z * perpendicularVector.z));

    //If the plane is beyond pLineSlope, and we do not want the ray to extend to infinity, then ignore this intersection.
    if(pExtend_To_Infinity == false && T > 1) return false;

    return true;
}

/// -------------------------------------------------------------------------------------------------------------------
/// This function returns true if a ray intersects a mesh.
/// -------------------------------------------------------------------------------------------------------------------
bool Raycast::Ray_Intersect_Mesh(Mesh* pMesh, glm::vec3 pStartPoint, glm::vec3 pSlopeLine, bool pExtend_To_Infinity=true, bool pCull_Backfaces=false)
{
    int TriangleCount = pMesh->GetTriangleCount();

    if(TriangleCount > 0)
    {
        for(int x = 0; x < TriangleCount; x++)
        {
            Triangle triangle = pMesh->GetTriangle(x);
            bool hit = Ray_Intersect_Triangle(pStartPoint, pSlopeLine, triangle.Vertice1, triangle.Vertice2, triangle.Vertice3, pExtend_To_Infinity, pCull_Backfaces);
            if (hit == true)
            {
                return true;
            }
        }
    }
    return false;
}

